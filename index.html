<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BoyOrGirl - Line Scratch Only</title>
  <style>
    body{
      margin:0;
      height:100vh;
      display:grid;
      place-items:center;
      background:#f6f6f6;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", sans-serif;
    }
    canvas{
      width:400px;
      height:400px;
      display:block;
      border-radius:16px;
      box-shadow:0 12px 30px rgba(0,0,0,.12);
      background:
        url("https://hsuanxcollection.files.wordpress.com/2022/10/brown-and-blue-minimalist-photography-birthday-gift-box-ideas-instagram-post.png?resize=668,668")
        no-repeat center / 100% 100%;
      touch-action:none; /* 防止手機滑動干擾畫線 */
    }
    .hint{
      margin-top:12px;
      color:#555;
      font-size:14px;
      text-align:center;
    }
  </style>
</head>
<body>
  <div>
    <canvas id="canvas" width="400" height="400"></canvas>
    <div class="hint">
      只能用「畫線」刮開灰色方塊；刮開每個方塊超過 60% 才會揭曉該方塊
    </div>
  </div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  // 兩個遮罩方塊定義
  const boxes = [
    { id: "left",  x: 40,  y: 160, w: 120, h: 120, revealed: false },
    { id: "right", x: 250, y: 160, w: 120, h: 120, revealed: false }
  ];

  // 揭曉門檻：只計算方塊內的透明比例
  const threshold = 0.60;

  // 畫上灰色遮罩（只畫在方塊內）
  function drawCovers() {
    ctx.globalCompositeOperation = "source-over";
    // 先清空 canvas 上層（不會影響 CSS 背景圖）
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#ddd";
    for (const b of boxes) {
      if (!b.revealed) ctx.fillRect(b.x, b.y, b.w, b.h);
    }

    // 畫線筆刷設定
    ctx.lineWidth = 22;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
  }

  drawCovers();

  // 取得 pointer 的 canvas 座標（支援縮放後的顯示尺寸）
  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (canvas.width / rect.width),
      y: (e.clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  // 判斷點是否落在任一方塊內（避免「任意處」也能刮）
  function hitBox(p) {
    return boxes.find(b =>
      !b.revealed &&
      p.x >= b.x && p.x <= b.x + b.w &&
      p.y >= b.y && p.y <= b.y + b.h
    );
  }

  let isDrawing = false;
  let last = { x: 0, y: 0 };
  let activeBox = null;

  function scratchLine(from, to) {
    // 只允許在 activeBox 存在時才刮
    if (!activeBox) return;

    ctx.save();

    // ★重點：限制刮除只能發生在該方塊區域（clip）
    ctx.beginPath();
    ctx.rect(activeBox.x, activeBox.y, activeBox.w, activeBox.h);
    ctx.clip();

    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    ctx.restore();
  }

  // 計算某一方塊內透明比例（只看該方塊）
  function calcTransparentRatio(box) {
    const img = ctx.getImageData(box.x, box.y, box.w, box.h);
    const data = img.data;
    let transparent = 0;
    const total = box.w * box.h;

    // alpha 通道 data[i+3]
    for (let i = 3; i < data.length; i += 4) {
      if (data[i] === 0) transparent++;
    }
    return transparent / total;
  }

  function tryReveal(box) {
    const ratio = calcTransparentRatio(box);
    if (ratio >= threshold) {
      box.revealed = true;

      // 清掉該方塊剩餘遮罩（確保完全揭曉）
      ctx.save();
      ctx.globalCompositeOperation = "destination-out";
      ctx.fillRect(box.x, box.y, box.w, box.h);
      ctx.restore();
    }
  }

  // Pointer events：一次支援滑鼠/觸控/筆
  canvas.addEventListener("pointerdown", (e) => {
    const p = getPos(e);
    activeBox = hitBox(p);         // 只有點在灰色方塊上才允許開始刮
    isDrawing = !!activeBox;
    last = p;
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!isDrawing) return;
    const p = getPos(e);
    scratchLine(last, p);
    last = p;
  });

  window.addEventListener("pointerup", () => {
    if (!isDrawing) return;
    isDrawing = false;

    // 放開後才計算刮開比例（避免每一筆都讀像素造成卡頓）
    if (activeBox) tryReveal(activeBox);
    activeBox = null;
  });

  // 可選：提供重置
  window.resetScratch = function(){
    for (const b of boxes) b.revealed = false;
    drawCovers();
  }
</script>
</body>
</html>
