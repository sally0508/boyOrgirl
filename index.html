<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BoyOrGirl</title>

  <style>
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:#f6f6f6;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", sans-serif;
    }

    .wrap{
      width:min(980px, 95vw);
    }

    input[type="text"], button{
      padding:8px 10px;
      border:1px solid #ddd;
      border-radius:10px;
      background:#fff;
      font-size:14px;
    }
    button{ cursor:pointer; }
    button:hover{ background:#fafafa; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    input:disabled{ background:#f3f3f3; color:#666; }

    /* ✅ 名字輸入區塊 */
    .panel{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap; /* 允許狀態文字換行，但不影響輸入組 */
      padding:10px 12px;
      background:#fff;
      border:1px solid #e9e9e9;
      border-radius:12px;
      box-shadow:0 8px 20px rgba(0,0,0,.06);
      margin-bottom:10px;
    }
    .panel strong{ color:#333; }

    /* ✅ 讓輸入框 + 確認按鈕永遠同一行 */
    .nameRow{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:nowrap;     /* ✅ 不換行 */
      white-space:nowrap;   /* ✅ 不換行 */
      flex: 0 0 auto;
      max-width: 100%;
    }
    .nameRow input{
      width: 180px;
      max-width: 42vw;      /* 窄螢幕縮小但仍跟按鈕同排 */
    }

    .status{
      flex-basis: 100%;     /* 狀態文字獨立一行（只它換行） */
      margin-top:2px;
      font-size:13px;
      color:#777;
      line-height:1.4;
    }
    .status.warn{ color:#c53030; font-weight:800; }

    /* ✅ RWD canvas */
    canvas{
      width:100%;
      max-width:980px;
      aspect-ratio: 720 / 430; /* 設計稿比例 */
      height:auto;

      display:block;
      border-radius:12px;
      box-shadow:0 12px 30px rgba(0,0,0,.12);

      background: url("Guess.jpg") no-repeat center / 100% 100%;
      touch-action:none;
    }

    .lockHint{
      margin-top:8px;
      color:#888;
      font-size:13px;
      text-align:center;
      line-height:1.4;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <!-- ✅ 先填名字才能刮（名字鎖死 + 一次機會） -->
    <div class="panel">
      <strong>請先填你的名字：</strong>

      <!-- ✅ 這組永遠同一行：輸入框 + 確認 -->
      <div class="nameRow">
        <input type="text" id="nameInput" placeholder="例如：思瑜" maxlength="8" />
        <button id="confirmNameBtn">確認</button>
      </div>

      <div class="status" id="statusText">尚未開始：請先輸入名字並按「確認」，才可以刮（只有一次機會）。</div>
    </div>

    <canvas id="canvas"></canvas>
    <div class="lockHint" id="lockHint"></div>

  </div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  const nameInput = document.getElementById("nameInput");
  const confirmNameBtn = document.getElementById("confirmNameBtn");
  const statusText = document.getElementById("statusText");
  const lockHintEl = document.getElementById("lockHint");

  // ====== ✅ 一次機會：localStorage（重新整理也不能重來）======
  const LS_NAME_KEY = "scratch_once_v3_name";
  const LS_CONFIRMED_KEY = "scratch_once_v3_confirmed";
  const LS_PLAYED_KEY = "scratch_once_v3_played";
  const LS_LOCKED_SIDE_KEY = "scratch_once_v3_lockedSide";

  // ====== 狀態 ======
  let playerName = "";
  let nameConfirmed = false;

  // 定義：第一次「真正開始刮」(pointerdown 命中可刮區) 就算用掉
  let hasPlayed = false;

  // 只能刮一邊
  let lockedSide = null; // "left" | "right"

  function setStatus(msg, warn=false){
    statusText.textContent = msg;
    statusText.classList.toggle("warn", warn);
  }

  function lockNameUI(){
    nameInput.disabled = true;
    confirmNameBtn.disabled = true;
  }

  function renderLockHint(){
    if (!lockHintEl) return;

    if (!nameConfirmed){
      lockHintEl.textContent = "尚未開始：請先填名字並按「確認」才可以刮（且只有一次機會）。";
      return;
    }

    const sideText = lockedSide
      ? `目前鎖定：只能刮 ${lockedSide === "left" ? "男生(左邊)" : "女生(右邊)"}。`
      : "尚未鎖定：第一次刮到哪邊就鎖哪邊。";

    if (!hasPlayed){
      lockHintEl.textContent = `Hi ${playerName}：名字已鎖定。${sideText}（開始刮就會用掉唯一一次機會）`;
    } else {
      lockHintEl.textContent = `Hi ${playerName}：你的機會已使用（不能重來）。${sideText}`;
    }
  }

  function confirmName(){
    if (hasPlayed){
      setStatus("你的機會已使用，無法再輸入或更改名字。", true);
      return;
    }

    const v = (nameInput.value || "").trim();
    if (!v){
      setStatus("請先輸入名字再按確認！", true);
      return;
    }

    playerName = v;
    nameConfirmed = true;

    // ✅ 名字確認後就鎖死
    lockNameUI();

    // ✅ 寫入 localStorage，避免重新整理偷改
    localStorage.setItem(LS_NAME_KEY, playerName);
    localStorage.setItem(LS_CONFIRMED_KEY, "1");

    setStatus(`Hi ${playerName}，名字已確認並鎖定！現在可以開始刮（只有一次機會）。`);
    renderLockHint();
  }

  confirmNameBtn.addEventListener("click", confirmName);
  nameInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") confirmName();
  });

  // ====== 你的「設計稿尺寸」：boxes 用這個座標系 ======
  const DESIGN_W = 720;
  const DESIGN_H = 430;

  const boxesDesign = [
    { id: "left",  x: 0,   y: 138, w: 346, h: 180, label: "男生", revealed: false },
    { id: "right", x: 400, y: 138, w: 346, h: 180, label: "女生", revealed: false }
  ];

  const threshold = 0.60;
  const brushSize = 26;

  // ====== RWD / DPR ======
  let dpr = 1;
  let viewW = 0, viewH = 0;

  function resizeCanvasToDisplaySize() {
    const rect = canvas.getBoundingClientRect();
    viewW = rect.width;
    viewH = rect.height;

    dpr = window.devicePixelRatio || 1;
    const needW = Math.round(viewW * dpr);
    const needH = Math.round(viewH * dpr);

    if (canvas.width !== needW || canvas.height !== needH) {
      canvas.width = needW;
      canvas.height = needH;
    }

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function getBoxesScaled() {
    const sx = viewW / DESIGN_W;
    const sy = viewH / DESIGN_H;

    return boxesDesign.map(b => ({
      ...b,
      x: b.x * sx,
      y: b.y * sy,
      w: b.w * sx,
      h: b.h * sy
    }));
  }

  function drawCovers() {
    resizeCanvasToDisplaySize();

    ctx.globalCompositeOperation = "source-over";
    ctx.clearRect(0, 0, viewW, viewH);

    const boxes = getBoxesScaled();

    // 灰色遮罩
    ctx.fillStyle = "#ddd";
    for (const b of boxes) {
      if (!b.revealed) ctx.fillRect(b.x, b.y, b.w, b.h);
    }

    // 文字
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const fontSize = Math.max(18, Math.round(viewW * 0.045));
    ctx.font = `800 ${fontSize}px 'Noto Sans TC', system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;

    for (const b of boxes) {
      if (b.revealed) continue;

      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;

      ctx.lineWidth = Math.max(4, Math.round(viewW * 0.006));
      ctx.strokeStyle = "white";
      ctx.fillStyle = "#333";

      ctx.strokeText(b.label, cx, cy);
      ctx.fillText(b.label, cx, cy);
    }

    // 筆刷
    ctx.lineWidth = brushSize;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";

    renderLockHint();
  }

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
  }

  function hitBox(p, boxes) {
    return boxes.find(b =>
      !b.revealed &&
      p.x >= b.x && p.x <= b.x + b.w &&
      p.y >= b.y && p.y <= b.y + b.h
    );
  }

  function scratchLine(box, from, to) {
    if (!box) return;

    ctx.save();
    ctx.beginPath();
    ctx.rect(box.x, box.y, box.w, box.h);
    ctx.clip();

    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    ctx.restore();
  }

  function calcTransparentRatio(box) {
    const x = Math.floor(box.x * dpr);
    const y = Math.floor(box.y * dpr);
    const w = Math.max(1, Math.floor(box.w * dpr));
    const h = Math.max(1, Math.floor(box.h * dpr));

    const img = ctx.getImageData(x, y, w, h);
    const data = img.data;
    const total = w * h;
    let transparent = 0;

    for (let i = 3; i < data.length; i += 4) {
      if (data[i] === 0) transparent++;
    }
    return transparent / total;
  }

  function tryReveal(box) {
    const ratio = calcTransparentRatio(box);
    if (ratio >= threshold) {
      const target = boxesDesign.find(b => b.id === box.id);
      if (target) target.revealed = true;

      ctx.save();
      ctx.globalCompositeOperation = "destination-out";
      ctx.fillRect(box.x, box.y, box.w, box.h);
      ctx.restore();
    }
  }

  // ====== Pointer events ======
  let isDrawing = false;
  let last = { x: 0, y: 0 };
  let activeBox = null;

  canvas.addEventListener("pointerdown", (e) => {
    if (!nameConfirmed){
      setStatus("請先輸入名字並按「確認」，才可以開始刮（只有一次機會）！", true);
      isDrawing = false;
      activeBox = null;
      return;
    }

    const boxes = getBoxesScaled();
    const p = getPos(e);
    const hit = hitBox(p, boxes);

    if (!hit) {
      isDrawing = false;
      activeBox = null;
      return;
    }

    // 第一次命中時鎖定邊（只能刮一邊）
    if (!lockedSide) {
      lockedSide = hit.id;
      localStorage.setItem(LS_LOCKED_SIDE_KEY, lockedSide);
      renderLockHint();
    }

    // 已鎖定就不能刮另一邊
    if (hit.id !== lockedSide) {
      setStatus(`Hi ${playerName}：你已鎖定「${lockedSide === "left" ? "男生(左邊)" : "女生(右邊)"}」，另一邊不能刮。`, true);
      isDrawing = false;
      activeBox = null;
      return;
    }

    // ✅ 第一次真正開始刮 -> 使用一次機會（鎖死）
    if (!hasPlayed) {
      hasPlayed = true;
      localStorage.setItem(LS_PLAYED_KEY, "1");
      setStatus(`Hi ${playerName}：你已開始刮，機會已使用（不能重來）。`);
      renderLockHint();
    }

    activeBox = hit;
    isDrawing = true;
    last = p;

    canvas.setPointerCapture?.(e.pointerId);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!isDrawing || !activeBox) return;
    const p = getPos(e);
    scratchLine(activeBox, last, p);
    last = p;
  });

  window.addEventListener("pointerup", (e) => {
    if (!isDrawing) return;
    isDrawing = false;

    if (activeBox) {
      tryReveal(activeBox);
      activeBox = null;
    }

    try { canvas.releasePointerCapture?.(e.pointerId); } catch {}
  });

  // ====== 初始化：讀取 localStorage（避免重新整理重來/改名）======
  (function init(){
    const savedName = localStorage.getItem(LS_NAME_KEY) || "";
    const savedConfirmed = localStorage.getItem(LS_CONFIRMED_KEY) === "1";
    const savedPlayed = localStorage.getItem(LS_PLAYED_KEY) === "1";
    const savedSide = localStorage.getItem(LS_LOCKED_SIDE_KEY);

    if (savedConfirmed && savedName){
      playerName = savedName;
      nameConfirmed = true;
      nameInput.value = savedName;
      lockNameUI();
    }

    if (savedSide === "left" || savedSide === "right"){
      lockedSide = savedSide;
    }

    if (savedPlayed){
      hasPlayed = true;
      setStatus(`Hi ${playerName || "玩家"}：你已使用一次機會（不能重來）。`);
    } else {
      setStatus(savedConfirmed
        ? `Hi ${playerName}：名字已鎖定！可以開始刮（只有一次機會）。`
        : "尚未開始：請先輸入名字並按「確認」，才可以刮（只有一次機會）。"
      );
    }

    drawCovers();
  })();

  window.addEventListener("resize", drawCovers);
</script>
</body>
</html>
