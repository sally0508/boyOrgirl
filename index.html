<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BoyOrGirl</title>

  <style>
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:#f6f6f6;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", sans-serif;
    }

    .wrap{
      width:min(980px, 95vw);
    }

    .toolbar{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
    }

    input[type="file"], button{
      padding:8px 10px;
      border:1px solid #ddd;
      border-radius:10px;
      background:#fff;
    }
    button{ cursor:pointer; }
    button:hover{ background:#fafafa; }

    /* ✅ RWD：canvas 寬度跟容器走，高度用 aspect-ratio 維持比例 */
    canvas{
      width:100%;
      max-width:980px;
      aspect-ratio: 720 / 430; /* 你的原始設計比例 */
      height:auto;

      display:block;
      border-radius:12px;
      box-shadow:0 12px 30px rgba(0,0,0,.12);

      background:
        url("Guess.jpg")
        no-repeat center / 100% 100%;

      touch-action:none; /* ✅ 手機必加：不然會滑動頁面導致刮不動 */
    }

    .hint{
      margin-top:12px;
      color:#555;
      font-size:14px;
      text-align:center;
      line-height:1.4;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="toolbar">
      <input type="file" id="bgPicker" accept="image/*">
      <button id="resetBtn">重置遮罩</button>
    </div>

    <canvas id="canvas"></canvas>

    <div class="hint">
      只能用畫線刮開灰色遮罩（刮開超過 60% 會自動揭曉）
    </div>
  </div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  // ====== 你的「設計稿尺寸」：boxes 用這個座標系 ======
  const DESIGN_W = 720;
  const DESIGN_H = 430;

  // ✅ boxes 仍然照你原本的值（設計稿座標）
  const boxesDesign = [
    { id: "left",  x: 0,  y: 138, w: 346, h: 180, label: "男生", revealed: false },
    { id: "right", x: 400, y: 138, w: 346, h: 180, label: "女生", revealed: false }
  ];

  const threshold = 0.60;
  const brushSize = 26;

  // ====== RWD 核心：同步 canvas 內部像素尺寸（含 DPR）=====
  let dpr = 1;
  let viewW = 0, viewH = 0; // CSS px 尺寸（顯示尺寸）

  function resizeCanvasToDisplaySize() {
    const rect = canvas.getBoundingClientRect();
    viewW = rect.width;
    viewH = rect.height;

    dpr = window.devicePixelRatio || 1;
    const needW = Math.round(viewW * dpr);
    const needH = Math.round(viewH * dpr);

    if (canvas.width !== needW || canvas.height !== needH) {
      canvas.width = needW;
      canvas.height = needH;
    }

    // ✅ 讓你用「CSS px」來畫：ctx 會自動乘上 DPR
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // ====== 把設計稿 boxes 轉成目前畫面比例 boxes ======
  function getBoxesScaled() {
    const sx = viewW / DESIGN_W;
    const sy = viewH / DESIGN_H;

    return boxesDesign.map(b => ({
      ...b,
      // 保留 revealed 狀態（因為 map 會複製）
      x: b.x * sx,
      y: b.y * sy,
      w: b.w * sx,
      h: b.h * sy
    }));
  }

  // ====== 畫遮罩 + 文字（灰底在下、字在上）=====
  function drawCovers() {
    resizeCanvasToDisplaySize();

    ctx.globalCompositeOperation = "source-over";
    ctx.clearRect(0, 0, viewW, viewH); // 用 CSS px 清

    const boxes = getBoxesScaled();

    // 1) 灰色遮罩（#ddd）
    ctx.fillStyle = "#ddd";
    for (const b of boxes) {
      if (!b.revealed) ctx.fillRect(b.x, b.y, b.w, b.h);
    }

    // 2) 文字（在遮罩上面）
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // 字體依畫面縮放（不然縮放會看起來怪）
    const fontSize = Math.max(18, Math.round(viewW * 0.045));
    ctx.font = `800 ${fontSize}px 'Noto Sans TC', system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;

    for (const b of boxes) {
      if (b.revealed) continue;

      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;

      ctx.lineWidth = Math.max(4, Math.round(viewW * 0.006));
      ctx.strokeStyle = "white";
      ctx.fillStyle = "#333";

      ctx.strokeText(b.label, cx, cy);
      ctx.fillText(b.label, cx, cy);
    }

    // 3) 刮除筆刷
    ctx.lineWidth = brushSize;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
  }

  // ====== 座標：轉成 CSS px（因為我們用 ctx.setTransform(dpr...)）=====
  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left),
      y: (e.clientY - rect.top)
    };
  }

  function hitBox(p, boxes) {
    return boxes.find(b =>
      !b.revealed &&
      p.x >= b.x && p.x <= b.x + b.w &&
      p.y >= b.y && p.y <= b.y + b.h
    );
  }

  function scratchLine(box, from, to) {
    if (!box) return;

    ctx.save();

    // ✅ 限制只能刮該方塊內（避免外面也被刮）
    ctx.beginPath();
    ctx.rect(box.x, box.y, box.w, box.h);
    ctx.clip();

    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    ctx.restore();
  }

  // ✅ getImageData 用「內部像素」座標，所以要乘上 dpr
  function calcTransparentRatio(box) {
    const x = Math.floor(box.x * dpr);
    const y = Math.floor(box.y * dpr);
    const w = Math.max(1, Math.floor(box.w * dpr));
    const h = Math.max(1, Math.floor(box.h * dpr));

    const img = ctx.getImageData(x, y, w, h);
    const data = img.data;
    const total = w * h;
    let transparent = 0;

    for (let i = 3; i < data.length; i += 4) {
      if (data[i] === 0) transparent++;
    }
    return transparent / total;
  }

  function tryReveal(box) {
    const ratio = calcTransparentRatio(box);
    if (ratio >= threshold) {
      // 反映回 boxesDesign 的 revealed（靠 id 對應）
      const target = boxesDesign.find(b => b.id === box.id);
      if (target) target.revealed = true;

      // 清掉剩餘遮罩
      ctx.save();
      ctx.globalCompositeOperation = "destination-out";
      ctx.fillRect(box.x, box.y, box.w, box.h);
      ctx.restore();
    }
  }

  // ====== Pointer events ======
  let isDrawing = false;
  let last = { x: 0, y: 0 };
  let activeBox = null;

  canvas.addEventListener("pointerdown", (e) => {
    const boxes = getBoxesScaled();
    const p = getPos(e);

    activeBox = hitBox(p, boxes);
    isDrawing = !!activeBox;
    last = p;
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!isDrawing || !activeBox) return;

    const p = getPos(e);
    scratchLine(activeBox, last, p);
    last = p;
  });

  window.addEventListener("pointerup", () => {
    if (!isDrawing) return;
    isDrawing = false;

    if (activeBox) {
      tryReveal(activeBox);
      activeBox = null;
    }
  });

  // ====== 重置 ======
  document.getElementById("resetBtn").addEventListener("click", () => {
    boxesDesign.forEach(b => b.revealed = false);
    drawCovers();
  });

  // ====== 用 input 選桌面背景圖 ======
  const bgPicker = document.getElementById("bgPicker");
  let bgUrl = null;

  bgPicker.addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (bgUrl) URL.revokeObjectURL(bgUrl);
    bgUrl = URL.createObjectURL(file);

    canvas.style.background = `url("${bgUrl}") no-repeat center / 100% 100%`;

    // 換背景後重繪一次
    drawCovers();
  });

  // 初始繪製 + 監聽縮放
  drawCovers();
  window.addEventListener("resize", () => {
    // ✅ 重要：縮放後要重畫，不然會出現你說的位置跑掉、刮不到
    drawCovers();
  });
</script>
</body>
</html>
